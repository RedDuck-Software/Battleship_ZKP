import "hashes/keccak/256bit" as keccak;
import "utils/pack/u32/unpack128" as unpack128;
import "utils/pack/u32/pack128" as pack128;
import "utils/casts/field_to_u8" as field_to_u8;
import "utils/casts/bool_array_to_u32_array" as bool_to_u32;
import "utils/casts/u8_to_bits" as u8_to_bits;
import "utils/casts/u32_from_bits" as u32_from_bits;

// 1. Submit hashes of fields (10x10)
// 2. Attack field X
// 3. Zero knowledge proof that X belongs to hash without revealing all data

// X,Y,Alignment (Vertical/Horizontal)
struct ship {
    u8 x;
    u8 y;
    bool alignment;
}

struct fieldState {
    ship carrier;
    ship battleship;
    ship destroyer;
    ship submarine;
    ship boat;
}

def hash(field carrierX, field carrierY, field shipX, field shipY) -> field[2] {
    u8 x1 = field_to_u8(carrierX);
    u8 y1 = field_to_u8(carrierY);
    u8 x2 = field_to_u8(shipX);
    u8 y2 = field_to_u8(shipY);

    u8[32] hash = keccak([x1, y1, x2, y2]);
    bool[8][32] mut bits = [[false; 32]; 8]; // 8*32 = 256 bits

    for u32 i in 0..32 { // 32

        bool[8] value = u8_to_bits(hash[i]);

        for u32 k in 0..8 { // 
            bits[i/4][(i%4)*8+k] = value[k]; // 4 is max (4*8 = 32)
        }
    }

    u32[8] mut hashCasted = [0; 8];

    for u32 i in 0..8 {
        hashCasted[i] = u32_from_bits(bits[i]);
    }

    return [pack128(hashCasted[0..4]), pack128(hashCasted[4..8])];
}

def main(private field crX, private field crY, private field spX, 
        private field spY,  public field fieldHash1, public field fieldHash2, 
        public field attackX, public field attackY, public bool hit) {
    assert(hash(crX, crY, spX, spY) == [fieldHash1, fieldHash2]);
    assert((crX == attackX && crY == attackY || spX == attackX && spY == attackY) == hit);

    return;
}